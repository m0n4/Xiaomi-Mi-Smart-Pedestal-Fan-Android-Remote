"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.retry = exports.sleep = exports.randomString = exports.randomInt = void 0;
/**
 * Returns random interger between 0 and 4294967295.
 *
 * @returns random interger between 0 and 4294967295
 */
function randomInt() {
    return Math.floor(Math.random() * 0xffffffff);
}
exports.randomInt = randomInt;
/**
 * Returns random string of given length.
 *
 * @param n - length of string
 * @returns random string of length `n`
 */
function randomString(n = 8) {
    return [...Array(n)].map(() => Math.random().toString(36)[2]).join("");
}
exports.randomString = randomString;
/**
 * Sleeps for specified time.
 *
 * @param ms - duration in milliseconds
 * @returns `Promise` which will be resolved after `ms` milliseconds
 */
async function sleep(ms) {
    await new Promise((resolve) => setTimeout(resolve, ms));
}
exports.sleep = sleep;
/**
 * Retries the specified asynchronous function the given amount of times in case of fail.
 *
 * @param attemptFunc - asynchronous function which will be retried
 * @param attempts - retries count
 * @param delay - delay in milliseconds between retries
 * @returns result of `attemptFunc` in case of success and
 *    throws error if `attemptFunc` fails `attempts` times
 */
async function retry(attemptFunc, attempts = 3, delay = 1000) {
    let remaining = attempts;
    async function makeAttempt() {
        const onError = async (err) => {
            if (remaining === 0) {
                throw err;
            }
            if (delay) {
                await sleep(delay);
            }
            return makeAttempt();
        };
        if (remaining > 0) {
            remaining--;
        }
        return attemptFunc().catch(onError);
    }
    return makeAttempt();
}
exports.retry = retry;
//# sourceMappingURL=utils.js.map