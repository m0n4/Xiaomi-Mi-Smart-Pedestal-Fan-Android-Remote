"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const dgram_1 = __importDefault(require("dgram"));
const errors_1 = require("./errors");
class Socket {
    /**
     * Represents a UDP socket.
     *
     * @param ip - IP address
     * @param port - port
     */
    constructor(ip, port) {
        this.ip = ip;
        this.port = port;
        this.socket = dgram_1.default.createSocket("udp4");
        this.version = parseInt(process.versions.node.split(".")[0]);
        this.connectPromise = null;
    }
    /**
     * Checks if socket is connected.
     *
     * @returns `true` if socket is connected and `false` otherwise
     */
    isConnected() {
        try {
            this.socket.remoteAddress();
            return true;
        }
        catch (err) {
            return false;
        }
    }
    /**
     * Connects socket to the provided IP and port.
     *
     * @returns `Promise` which will be resolved when socket is connected
     *
     * @remarks
     * If called simultaneous do connect only once and return same promise for
     * all callers
     */
    connect() {
        if (!this.connectPromise) {
            this.connectPromise = new Promise((resolve) => {
                this.socket.connect(this.port, this.ip, () => {
                    resolve();
                });
            }).finally(() => {
                this.connectPromise = null;
            });
        }
        return this.connectPromise;
    }
    /**
     * Sends data to the socket and returns response wrapped in `Promise`.
     *
     * @remarks
     * Because data is sent using UDP, responses may come in random order
     * and it is requred to parse binary response and check if it matches
     * the request.
     *
     * @param data - data to send
     * @param parse - parse function
     * @param match - match function (checks if response matches the request)
     * @param timeout - response timeout
     * @returns `Promise` which will be resolved when matched response come or
     *    rejected in case of error or timeout
     */
    async send(data, parse, match, timeout = 5000) {
        // `connect` function was added in v12 of NodeJS.
        // https://nodejs.org/api/dgram.html#dgram_socket_connect_port_address_callback
        if (this.version >= 12) {
            if (!this.isConnected()) {
                await this.connect();
            }
        }
        let timer;
        let onMessage, onError;
        const done = (onFinish) => {
            if (timer) {
                clearTimeout(timer);
            }
            this.socket.removeListener("message", onMessage);
            this.socket.removeListener("error", onError);
            onFinish();
        };
        const resultPromise = new Promise((resolve, reject) => {
            onMessage = (msg) => {
                try {
                    const parsed = parse(msg);
                    if (match(parsed)) {
                        done(() => resolve(parsed));
                    }
                }
                catch (err) {
                    done(() => reject(err));
                    return;
                }
            };
            onError = (err) => {
                done(() => reject(new errors_1.SocketError(err.message)));
            };
            if (timeout) {
                timer = setTimeout(() => {
                    done(() => reject(new errors_1.SocketError("Timeout")));
                }, timeout);
            }
            this.socket.on("message", onMessage);
            this.socket.on("error", onError);
            const callback = (err) => {
                if (err) {
                    onError(err);
                }
            };
            if (this.version >= 12) {
                this.socket.send(data, callback);
            }
            else {
                // Older NodeJS versions don't have "connected UDP socket",
                // so we need to pass address and port.
                this.socket.send(data, this.port, this.ip, callback);
            }
        });
        return resultPromise;
    }
    /**
     * Closes socket.
     */
    close() {
        return new Promise((resolve) => {
            try {
                this.socket.close(() => {
                    resolve();
                });
            }
            catch (err) {
                resolve();
            }
        });
    }
}
exports.default = Socket;
//# sourceMappingURL=socket.js.map