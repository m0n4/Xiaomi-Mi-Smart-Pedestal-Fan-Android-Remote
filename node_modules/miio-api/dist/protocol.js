"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const packet_1 = __importDefault(require("./packet"));
const errors_1 = require("./errors");
const crypto_1 = require("./crypto");
class Protocol {
    /**
     * Represents miIO protocol.
     *
     * @param deviceId - device id
     * @param token - device token
     */
    constructor(deviceId, token) {
        this.deviceId = deviceId;
        this.token = token;
        this.key = crypto_1.hash(token);
        this.iv = crypto_1.hash(Buffer.concat([this.key, token]));
    }
    /**
     * Checks if `Packet` is handshake packet.
     *
     * @param packet - `Packet` to check
     * @returns `true` if packet is handshake packet and `false` otherwise
     */
    static isHandshake(packet) {
        return packet.length === packet_1.default.HEADER_SIZE;
    }
    /**
     * Returns ready to send `Packet` for the given `Request`.
     *
     * @param req - request
     * @param req.id - random int
     * @param req.method - device method to call
     * @param req.params - method params
     * @param timestamp - device timestamp
     * @returns `Packet` for the given `req` and `timestamp`
     */
    packRequest(req, timestamp) {
        // If no params, set default to []
        const payload = {
            ...req,
            params: req.params || [],
        };
        const data = Buffer.from(JSON.stringify(payload) + "\x00");
        const encryptedData = crypto_1.encrypt(this.key, this.iv, data);
        // Fields required to calculate checksum
        const fields = {
            deviceId: this.deviceId,
            timestamp: timestamp,
            data: encryptedData,
        };
        return new packet_1.default({ ...fields, checksum: this.calcChecksum(fields) });
    }
    /**
     * Extracts device reponse from `Packet`.
     *
     * @param packet - response `Packet`
     * @returns `Response` extracted from the given `packet`
     */
    unpackResponse(packet) {
        if (!this.validateChecksum(packet)) {
            throw new errors_1.ProtocolError("Invalid packet checksum");
        }
        const decrypted = crypto_1.decrypt(this.key, this.iv, packet.data);
        const response = JSON.parse(decrypted.toString());
        return response;
    }
    /**
     * Calculates a checksum for the given `Packet`.
     *
     * @param fields - `Packet` fields required for checksum calculation.
     * @returns checksum for `Packet` constructed from `fields`
     */
    calcChecksum(fields) {
        // Build dummy packet with token in "checksum" field
        // to calculate actual checksum.
        const dummy = new packet_1.default({
            ...fields,
            checksum: this.token,
        });
        return crypto_1.hash(dummy.toBuffer());
    }
    /**
     * Validates checksum of the given `Packet`.
     *
     * @param packet - `Packet` to validate
     * @returns `true` if checksum is correct and `false` otherwise
     */
    validateChecksum(packet) {
        const { checksum: actual, ...fields } = packet;
        const expected = this.calcChecksum(fields);
        return expected.equals(actual);
    }
}
Protocol.HANDSHAKE_PACKET = new packet_1.default({
    deviceId: 0xffffffff,
    timestamp: 0xffffffff,
    checksum: Buffer.alloc(packet_1.default.CHECKSUM_SIZE, 0xff),
    data: Buffer.alloc(0),
}, 0xffffffff);
exports.default = Protocol;
//# sourceMappingURL=protocol.js.map