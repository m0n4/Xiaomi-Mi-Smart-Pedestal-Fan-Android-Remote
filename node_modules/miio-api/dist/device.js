"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const protocol_1 = __importDefault(require("./protocol"));
const packet_1 = __importDefault(require("./packet"));
const socket_1 = __importDefault(require("./socket"));
const logger_1 = __importDefault(require("./logger"));
const errors_1 = require("./errors");
const utils_1 = require("./utils");
class Device {
    /**
     * Represents a miIO `Device`.
     *
     * @param params - device parameters
     * @param params.address - device IP address
     * @param params.token - device token
     * @param params.deviceId - device identifier
     * @param params.socket - socket
     * @param params.lastSeenAt - time of last communication with device
     * @param params.timestamp - last device timestamp
     *
     * @remarks
     * It is recommended not to create device using this constructor but to
     * use `Device.discover` method instead.
     * Parameters `socket`, `lastSeenAt` and `timestamp` are optional and introduced only to
     * be able to avoid double handshake at the start.
     */
    constructor(params) {
        this.id = params.deviceId;
        this.protocol = new protocol_1.default(params.deviceId, Buffer.from(params.token, "hex"));
        this.socket = params.socket || new socket_1.default(params.address, Device.PORT);
        this.timestamp = params.timestamp || 0;
        this.lastSeenAt = params.lastSeenAt || 0;
        this.handshakePromise = null;
        this.log = logger_1.default.extend(params.address);
    }
    /**
     * Makes handshake.
     *
     * @param socket - device socket
     * @param options - call options
     * @returns `Promise` with handshake result
     */
    static async handshake(socket, callOptions) {
        const options = { ...Device.DEFAULT_CALL_OPTIONS, ...callOptions };
        const logWithId = logger_1.default.extend(socket.ip).extend(utils_1.randomString());
        let attempt = 0;
        const packet = await utils_1.retry(async () => {
            const requestPacket = protocol_1.default.HANDSHAKE_PACKET;
            logWithId("-> %O", requestPacket);
            attempt++;
            const requestBuffer = requestPacket.toBuffer();
            logWithId("#%d ->\n%H", attempt, requestBuffer);
            return await socket.send(requestBuffer, (msg) => {
                logWithId("<-\n%H", msg);
                return packet_1.default.fromBuffer(msg);
            }, (packet) => {
                logWithId("<- %O", packet);
                return protocol_1.default.isHandshake(packet);
            }, options.timeout);
        }, options.attempts, options.delay);
        return {
            deviceId: packet.deviceId,
            timestamp: packet.timestamp,
        };
    }
    /**
     * Connects to device, makes handshake and returns ready to use `Device` instance.
     *
     * @param params - discover parameters
     * @param params.address - device IP address
     * @param params.token - device token
     * @param callOptions - additional options
     * @param callOptions.attempts - handshake attempts
     * @param callOptions.delay - delay between attempts
     * @param callOptions.timeout - handshake response timeout
     * @returns `Device` instance
     */
    static async discover(params, callOptions) {
        const options = { ...Device.DEFAULT_CALL_OPTIONS, ...callOptions };
        const socket = new socket_1.default(params.address, Device.PORT);
        let handshake;
        // Exception is handled to be able to close socket in case of error.
        try {
            handshake = await Device.handshake(socket, options);
        }
        catch (err) {
            await socket.close();
            throw err;
        }
        return new Device({
            deviceId: handshake.deviceId,
            token: params.token,
            address: params.address,
            socket: socket,
            timestamp: handshake.timestamp,
            lastSeenAt: Date.now(),
        });
    }
    /**
     * Makes handshake.
     *
     * @param options - call options
     * @returns `Promise` with handshake result
     *
     * @remarks
     * If called simultaneous do handshake only once and returns the same
     * promise for all callers
     *
     */
    handshake(options) {
        if (!this.handshakePromise) {
            this.handshakePromise = Device.handshake(this.socket, options).finally(() => {
                this.handshakePromise = null;
            });
        }
        return this.handshakePromise;
    }
    /**
     * Returns result of device method call.
     *
     * @param method - device method to call
     * @param params - method parameters
     * @param callOptions - additional options
     * @param callOptions.attempts - call attempts
     * @param callOptions.delay - delay between attempts
     * @param callOptions.timeout - call response timeout
     * @returns result `method` call
     */
    async call(method, params, callOptions) {
        const logWithId = this.log.extend(utils_1.randomString());
        const options = { ...Device.DEFAULT_CALL_OPTIONS, ...callOptions };
        const secondsPassed = Math.floor((Date.now() - this.lastSeenAt) / 1000);
        if (secondsPassed > Device.MAX_CALL_INTERVAL) {
            logWithId("-> handshake");
            const { timestamp } = await this.handshake(options);
            this.timestamp = timestamp;
            this.lastSeenAt = Date.now();
        }
        const id = utils_1.randomInt();
        const body = { id, method, params };
        logWithId("-> %O", body);
        const requestPacket = this.protocol.packRequest(body, this.timestamp);
        logWithId("-> %O", requestPacket);
        const requestBuffer = requestPacket.toBuffer();
        let attempt = 0;
        const { responsePacket, response } = await utils_1.retry(async () => {
            attempt++;
            logWithId("#%d ->\n%H", attempt, requestBuffer);
            return await this.socket.send(requestBuffer, (responseBuffer) => {
                logWithId("<-\n%H", responseBuffer);
                const responsePacket = packet_1.default.fromBuffer(responseBuffer);
                logWithId("<- %O", responsePacket);
                const response = !protocol_1.default.isHandshake(responsePacket)
                    ? this.protocol.unpackResponse(responsePacket)
                    : undefined;
                return { responsePacket, response };
            }, ({ response }) => {
                logWithId("<- %O", response);
                if ((response === null || response === void 0 ? void 0 : response.id) === id) {
                    return true;
                }
                return false;
            }, options.timeout);
        }, options.attempts, options.delay);
        this.timestamp = responsePacket.timestamp;
        this.lastSeenAt = Date.now();
        if (!response) {
            throw new errors_1.DeviceError("Empty response");
        }
        if ("error" in response) {
            const err = response.error;
            throw new errors_1.DeviceError(`Device responded with error: "${err.message}". Code: ${err.code}`);
        }
        return response.result;
    }
    /**
     * Cleans resources associated with the device.
     */
    async destroy() {
        await this.socket.close();
    }
}
Device.PORT = 54321;
Device.MAX_CALL_INTERVAL = 60;
Device.DEFAULT_CALL_OPTIONS = {
    attempts: 3,
    delay: 3000,
    timeout: 3000,
};
exports.default = Device;
//# sourceMappingURL=device.js.map